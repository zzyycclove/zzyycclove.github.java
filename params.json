{"name":"Zzyycclove.GitHub.java","tagline":"Lucius的java技术博客","body":"##计算结构体的大小\r\n运算符sizeof可以计算出给定类型的大小，对于32位系统来说，\r\nsizeof(char) = 1; sizeof(int) = 4。\r\n基本数据类型的大小很好计算，我们来看一下如何计算构造数据类型的大小。\r\n    C语言中的构造数据类型有三种：数组、结构体和共用体。\r\n数组是相同类型的元素的集合，只要会计算单个元素的大小，整个数组所占空间等于基础元素大小乘上元素的个数。\r\n结构体中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到系统在存储结构体变量时的地址对齐问题。看下面这样的一个结构体：\r\n       struct stu1\r\n       {\r\n       int    i;\r\n       char c;\r\n       int j;\r\n       }；\r\n先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。\r\n实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：\r\n一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）\r\n二、结构体大小必须是所有成员大小的整数倍。\r\n对照第一条，上面的例子中前两个成员的偏移量都满足要求，但第三个成员的偏移量为5，并不是自身(int)大小的整数倍。编译器在处理时会在第二个成员后面补上3个空字节，使得第三个成员的偏移量变成8。\r\n对照第二条，结构体大小等于最后一个成员的偏移量加上其大小，上面的例子中计算出来的大小为12，满足要求。\r\n再看一个满足第一条，不满足第二条的情况\r\nstruct stu2\r\n       {\r\n       int   k;\r\n       short t;\r\n}；\r\n成员k的偏移量为0；成员t的偏移量为4，都不需要调整。但计算出来的大小为6，显然不是成员k大小的整数倍。因此，编译器会在成员t后面补上2个字节，使得结构体的大小变成8从而满足第二个要求。\r\n由此可见，大家在定义结构体类型时需要考虑到字节对齐的情况，不同的顺序会影响到结构体的大小。对比下面两种定义顺序\r\n```\r\nstruct stu3                              struct stu4\r\n{                                      {\r\n char c1;                               char c1;\r\n int i;                                  char c2;\r\n char c2;                               int   i;\r\n}                                      }\r\n```\r\n虽然结构体stu3和stu4中成员都一样，但sizeof(struct stu3)的值为12而sizeof(struct stu4)的值为8。\r\n如果结构体中的成员又是另外一种结构体类型时应该怎么计算呢？只需把其展开即可。但有一点需要注意，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。看下面的例子，\r\nstruct temp\r\n       {\r\n       short i;    +1\r\n       struct\r\n       {\r\n          char c;  +5\r\n          int j;   +6\r\n       } ss;       +10+2\r\n          int k;   +4\r\n}；             =16\r\n结构体temp的成员ss.c的偏移量应该是4，而不是2。整个结构体大小应该是16。\r\n注意在linux下时，整个结构体的大小应该是：\r\nchar对齐模数是1，short是2，int是4，float是4，double(linux是4，windows是8)\r\n所以对于如下的结构体：(32位机,默认设置)\r\nstruct temp\r\n {\r\n        int   i;       \r\n        double  j;   \r\n };\r\n对于在WINDOWNS系统下，整个结构的大小应该是16,在LINUX系统下，整个结构的大小应该是12\r\n \r\n当控制结构的成员封装到内存并为模块中的所有结构指定相同的封装时。\r\n**#pragma pack(n)** 是把所有的成员的对齐模数都设置为n，比如设置为1后，就是一个一个的挨着存放，结构大小也就是成员大小之和了。n必须小于默认的对齐模数，也就是说只能向小设，不能向大设\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}